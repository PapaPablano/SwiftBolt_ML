# Add this to ml/src/models/enhanced_options_ranker.py

import numpy as np
import pandas as pd
from datetime import datetime

from .pop_calculator import ProbabilityOfProfitCalculator
from .earnings_analyzer import EarningsIVAnalyzer
from .extrinsic_calculator import ExtrinsicIntrinsicCalculator
from .pcr_analyzer import PutCallRatioAnalyzer


class EnhancedOptionsRanker:
    """
    Enhanced Options Ranker with P0 modules (4 new scoring components).
    """
    
    def __init__(self):
        self.pop_calc = ProbabilityOfProfitCalculator()
        self.earnings_analyzer = EarningsIVAnalyzer()
        self.extrinsic_calc = ExtrinsicIntrinsicCalculator()
        self.pcr_analyzer = PutCallRatioAnalyzer()
    
    def rank_options_with_enhancements(
        self,
        options_df: pd.DataFrame,
        underlying_price: float,
        trend_analysis: dict,
        historical_vol: float,
        earnings_date: str = None
    ) -> pd.DataFrame:
        """
        Rank options with original 8 components + 4 new P0 modules.
        """
        # Calculate all scores
        base_scores = self._compute_base_scores(options_df, underlying_price, trend_analysis, historical_vol)
        pop_scores = self._score_pop_and_rr(options_df)
        earnings_scores = self._score_earnings_iv(options_df, earnings_date)
        extrinsic_scores = self._score_extrinsic_richness(options_df, historical_vol)
        pcr_scores = self._score_put_call_ratio(options_df)
        
        # Weighted composite
        options_df['ml_score_original'] = base_scores  # 50%
        options_df['ml_score_pop'] = pop_scores * 0.12
        options_df['ml_score_earnings'] = earnings_scores * 0.10
        options_df['ml_score_extrinsic'] = extrinsic_scores * 0.10
        options_df['ml_score_pcr'] = pcr_scores * 0.08
        
        options_df['ml_score_enhanced'] = (
            (base_scores * 0.5) +
            (pop_scores * 0.12) +
            (earnings_scores * 0.10) +
            (extrinsic_scores * 0.10) +
            (pcr_scores * 0.08)
        ) * 100  # Normalize to 0-100
        
        return options_df.sort_values('ml_score_enhanced', ascending=False)
    
    def _compute_base_scores(self, options_df, underlying_price, trend_analysis, historical_vol):
        """
        Original 8-component score (from your existing code).
        Return normalized 0-1 score.
        """
        # TODO: Call your existing ranker logic here
        # For now, placeholder returning normalized scores
        return np.ones(len(options_df)) * 0.65
    
    def _score_pop_and_rr(self, options_df: pd.DataFrame) -> np.ndarray:
        """New P0 module: PoP + R/R"""
        scores = []
        for _, row in options_df.iterrows():
            pop_data = self.pop_calc.calculate_pop(
                underlying_price=row['underlyingPrice'],
                strike=row['strike'],
                side=row['side'],
                bid=row['bid'],
                ask=row['ask'],
                delta=row['delta']
            )
            rr_data = self.pop_calc.calculate_risk_reward_ratio(
                strike=row['strike'],
                underlying_price=row['underlyingPrice'],
                bid=row['bid'],
                ask=row['ask'],
                side=row['side']
            )
            score = self.pop_calc.score_pop_and_rr(pop_data, rr_data)
            scores.append(score)
        return np.array(scores)
    
    def _score_earnings_iv(self, options_df: pd.DataFrame, earnings_date: str = None) -> np.ndarray:
        """New P0 module: Earnings IV"""
        if earnings_date is None:
            from datetime import timedelta
            earnings_date = (datetime.today() + timedelta(days=45)).strftime('%Y-%m-%d')
        
        scores = []
        for _, row in options_df.iterrows():
            days_to_earnings = (datetime.strptime(earnings_date, '%Y-%m-%d') - datetime.today()).days
            days_to_expiry = (datetime.strptime(row['expiration'], '%Y-%m-%d') - datetime.today()).days
            
            earnings_data = self.earnings_analyzer.calculate_earnings_impact_on_iv(
                current_iv=row['impliedVolatility'],
                historical_iv=row.get('historicalVolatility', 0.20),
                days_to_earnings=days_to_earnings,
                days_to_expiry=days_to_expiry
            )
            score = self.earnings_analyzer.score_earnings_strategy(
                earnings_data, side=row['side'], expiration=row['expiration'],
                underlying_price=row['underlyingPrice'], strike=row['strike'],
                strategy_type='auto'
            )
            scores.append(score)
        return np.array(scores)
    
    def _score_extrinsic_richness(self, options_df: pd.DataFrame, historical_vol: float) -> np.ndarray:
        """New P0 module: Extrinsic/Intrinsic"""
        scores = []
        for _, row in options_df.iterrows():
            days_to_exp = (datetime.strptime(row['expiration'], '%Y-%m-%d') - datetime.today()).days
            ext_data = self.extrinsic_calc.calculate_extrinsic_intrinsic_ratio(
                strike=row['strike'],
                underlying_price=row['underlyingPrice'],
                side=row['side'],
                bid=row['bid'],
                ask=row['ask'],
                days_to_expiry=days_to_exp
            )
            score = self.extrinsic_calc.score_extrinsic_richness(
                ext_data,
                implied_vol=row['impliedVolatility'],
                historical_vol=historical_vol,
                strategy_type='auto'
            )
            scores.append(score)
        return np.array(scores)
    
    def _score_put_call_ratio(self, options_df: pd.DataFrame) -> np.ndarray:
        """New P0 module: Put-Call Ratio"""
        pcr_data = self.pcr_analyzer.analyze_put_call_ratio(options_df)
        scores = []
        for _, row in options_df.iterrows():
            score = self.pcr_analyzer.score_pcr_opportunity(
                pcr_data, side=row['side'], use_contrarian=True
            )
            scores.append(score)
        return np.array(scores)
