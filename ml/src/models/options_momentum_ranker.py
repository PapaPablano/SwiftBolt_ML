"""Options Momentum Ranking System - Statistical & Analytical Framework.

Implements a rigorous quantitative methodology for ranking options by combining:
1. Momentum Analysis (40%) - Price acceleration, volume flow, OI growth
2. Valuation Assessment (35%) - IV Rank, IV Percentile, liquidity
3. Greeks-Based Risk Scoring (25%) - Delta, Gamma, Vega, Theta alignment

The composite score (0-100) enables systematic option selection based on
statistical properties rather than intuition.
"""

import logging
import math
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional

import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of trading signals generated by the ranking system."""
    DISCOUNT = "discount"           # Low IV + momentum = buy opportunity
    MOMENTUM_RUNNER = "runner"      # Hot momentum + high volume
    GREEKS_ALIGNED = "greeks"       # Optimal Greeks for directional trade
    BUY = "buy"                     # Composite signal meeting threshold


@dataclass
class OptionSignals:
    """Trading signals for an option contract."""
    discount: bool = False
    runner: bool = False
    greeks_aligned: bool = False
    buy: bool = False
    signal_types: list = None

    def __post_init__(self):
        self.signal_types = []
        if self.discount:
            self.signal_types.append(SignalType.DISCOUNT)
        if self.runner:
            self.signal_types.append(SignalType.MOMENTUM_RUNNER)
        if self.greeks_aligned:
            self.signal_types.append(SignalType.GREEKS_ALIGNED)
        if self.buy:
            self.signal_types.append(SignalType.BUY)


@dataclass
class IVStatistics:
    """52-week IV statistics for a symbol."""
    iv_high: float
    iv_low: float
    iv_median: float
    iv_current: float
    days_of_data: int = 252

    @property
    def iv_rank(self) -> float:
        """Calculate IV Rank: (current - low) / (high - low) * 100."""
        if self.iv_high == self.iv_low:
            return 50.0
        return ((self.iv_current - self.iv_low) / (self.iv_high - self.iv_low)) * 100

    @property
    def is_cheap(self) -> bool:
        """IV is in bottom 30% of range."""
        return self.iv_rank < 30

    @property
    def is_expensive(self) -> bool:
        """IV is in top 70% of range."""
        return self.iv_rank > 70


class OptionsMomentumRanker:
    """
    Advanced options ranking using the Momentum-Value-Greeks framework.

    Composite Score = Momentum(40%) + Value(35%) + Greeks(25%)

    Each component normalized to 0-100 scale for interpretability.
    """

    # Framework weights
    MOMENTUM_WEIGHT = 0.40
    VALUE_WEIGHT = 0.35
    GREEKS_WEIGHT = 0.25

    # Momentum sub-weights
    PRICE_MOMENTUM_WEIGHT = 0.50
    VOLUME_OI_WEIGHT = 0.30
    OI_GROWTH_WEIGHT = 0.20

    # Value sub-weights
    IV_RANK_WEIGHT = 0.60
    SPREAD_WEIGHT = 0.40

    # Greeks sub-weights
    DELTA_WEIGHT = 0.50
    GAMMA_WEIGHT = 0.35
    VEGA_WEIGHT = 0.10
    THETA_WEIGHT = 0.05  # Applied as penalty

    # Thresholds
    OPTIMAL_DELTA_MIN = 0.40
    OPTIMAL_DELTA_MAX = 0.70
    OPTIMAL_DELTA_TARGET = 0.55
    GAMMA_EXCELLENT_THRESHOLD = 0.04
    GAMMA_GOOD_THRESHOLD = 0.02
    VOLUME_OI_STRONG = 0.20
    VOLUME_OI_NORMAL = 0.10
    SPREAD_CAP = 50.0  # Cap spread % at 50 for scoring

    # Signal thresholds
    DISCOUNT_IV_RANK_THRESHOLD = 30
    DISCOUNT_MOMENTUM_THRESHOLD = 50
    DISCOUNT_SPREAD_THRESHOLD = 2.0
    RUNNER_MOMENTUM_THRESHOLD = 75
    RUNNER_VOLUME_THRESHOLD = 100
    RUNNER_VOL_OI_THRESHOLD = 0.10
    RUNNER_SPREAD_THRESHOLD = 3.0
    GREEKS_SPREAD_THRESHOLD = 2.0
    BUY_COMPOSITE_THRESHOLD = 65

    def __init__(
        self,
        momentum_weight: float = 0.40,
        value_weight: float = 0.35,
        greeks_weight: float = 0.25,
    ):
        """Initialize ranker with configurable weights.

        Args:
            momentum_weight: Weight for momentum score (default 0.40)
            value_weight: Weight for value score (default 0.35)
            greeks_weight: Weight for Greeks score (default 0.25)
        """
        # Validate weights sum to 1
        total = momentum_weight + value_weight + greeks_weight
        if abs(total - 1.0) > 0.001:
            logger.warning(f"Weights sum to {total}, normalizing")
            momentum_weight /= total
            value_weight /= total
            greeks_weight /= total

        self.MOMENTUM_WEIGHT = momentum_weight
        self.VALUE_WEIGHT = value_weight
        self.GREEKS_WEIGHT = greeks_weight

        logger.info(
            f"OptionsMomentumRanker initialized: "
            f"Momentum={momentum_weight:.0%}, Value={value_weight:.0%}, Greeks={greeks_weight:.0%}"
        )

    def rank_options(
        self,
        options_df: pd.DataFrame,
        iv_stats: Optional[IVStatistics] = None,
        options_history: Optional[pd.DataFrame] = None,
        underlying_trend: str = "neutral",
    ) -> pd.DataFrame:
        """
        Rank options using the Momentum-Value-Greeks framework.

        Args:
            options_df: Current options chain with columns:
                - strike, side (call/put), expiration
                - bid, ask, last, mark
                - volume, openInterest (or open_interest)
                - delta, gamma, theta, vega, rho
                - impliedVolatility (or implied_vol, iv)
            iv_stats: 52-week IV statistics for the underlying
            options_history: Historical options data (5+ days) for momentum
            underlying_trend: bullish/neutral/bearish

        Returns:
            DataFrame with added scoring columns and sorted by composite_rank
        """
        if options_df.empty:
            logger.warning("No options data to rank")
            return options_df

        df = self._normalize_columns(options_df.copy())

        # Calculate component scores
        df = self._calculate_value_scores(df, iv_stats)
        df = self._calculate_momentum_scores(df, options_history)
        df = self._calculate_greeks_scores(df, underlying_trend)

        # Calculate composite rank (0-100)
        df["composite_rank"] = (
            df["momentum_score"] * self.MOMENTUM_WEIGHT +
            df["value_score"] * self.VALUE_WEIGHT +
            df["greeks_score"] * self.GREEKS_WEIGHT
        )

        # Generate signals
        df = self._generate_signals(df)

        # Sort by composite rank
        df = df.sort_values("composite_rank", ascending=False).reset_index(drop=True)

        # Log statistics
        self._log_ranking_stats(df)

        return df

    def _normalize_columns(self, df: pd.DataFrame) -> pd.DataFrame:
        """Normalize column names for consistent processing."""
        rename_map = {
            "impliedVolatility": "iv",
            "implied_vol": "iv",
            "implied_volatility": "iv",
            "openInterest": "open_interest",
            "option_type": "side",
        }
        df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})

        # Ensure required columns exist
        if "mid" not in df.columns and "bid" in df.columns and "ask" in df.columns:
            df["mid"] = (df["bid"] + df["ask"]) / 2
        if "mark" not in df.columns:
            df["mark"] = df.get("mid", df.get("last", 0))

        return df

    # =========================================================================
    # VALUE SCORING (35% of total)
    # =========================================================================

    def _calculate_value_scores(
        self,
        df: pd.DataFrame,
        iv_stats: Optional[IVStatistics] = None,
    ) -> pd.DataFrame:
        """Calculate value score from IV Rank and bid-ask spread.

        Value Score = (100 - IVR) × 0.60 + (100 - Spread%) × 0.40
        """
        # IV Rank component (60% of value)
        df["iv_rank"] = self._calculate_iv_rank(df, iv_stats)
        df["iv_rank_score"] = 100 - df["iv_rank"]  # Lower IVR = higher score

        # Bid-Ask Spread component (40% of value)
        df["spread_pct"] = self._calculate_spread_pct(df)
        df["spread_score"] = 100 - df["spread_pct"].clip(upper=self.SPREAD_CAP)

        # Combined Value Score
        df["value_score"] = (
            df["iv_rank_score"] * self.IV_RANK_WEIGHT +
            df["spread_score"] * self.SPREAD_WEIGHT
        )

        return df

    def _calculate_iv_rank(
        self,
        df: pd.DataFrame,
        iv_stats: Optional[IVStatistics] = None,
    ) -> pd.Series:
        """Calculate IV Rank: (IV_current - IV_52low) / (IV_52high - IV_52low) × 100.

        If no IV stats provided, estimate from current chain.
        """
        if "iv" not in df.columns:
            logger.warning("No IV column found, defaulting to 50")
            return pd.Series(50.0, index=df.index)

        if iv_stats:
            # Use provided 52-week statistics
            iv_range = iv_stats.iv_high - iv_stats.iv_low
            if iv_range > 0:
                iv_rank = ((df["iv"] - iv_stats.iv_low) / iv_range) * 100
            else:
                iv_rank = pd.Series(50.0, index=df.index)
        else:
            # Estimate from current chain (ATM IV as proxy)
            atm_iv = df["iv"].median()
            iv_min = df["iv"].min()
            iv_max = df["iv"].max()
            iv_range = iv_max - iv_min

            if iv_range > 0:
                iv_rank = ((df["iv"] - iv_min) / iv_range) * 100
            else:
                iv_rank = pd.Series(50.0, index=df.index)

            logger.debug(f"Estimated IV Rank from chain: min={iv_min:.2%}, max={iv_max:.2%}")

        return iv_rank.clip(0, 100)

    def _calculate_spread_pct(self, df: pd.DataFrame) -> pd.Series:
        """Calculate bid-ask spread as percentage of mid price."""
        if "bid" not in df.columns or "ask" not in df.columns:
            return pd.Series(5.0, index=df.index)  # Default 5% spread

        mid = (df["bid"] + df["ask"]) / 2
        spread = df["ask"] - df["bid"]

        # Avoid division by zero
        spread_pct = np.where(mid > 0, (spread / mid) * 100, 100)

        return pd.Series(spread_pct, index=df.index)

    # =========================================================================
    # MOMENTUM SCORING (40% of total)
    # =========================================================================

    def _calculate_momentum_scores(
        self,
        df: pd.DataFrame,
        options_history: Optional[pd.DataFrame] = None,
    ) -> pd.DataFrame:
        """Calculate momentum score from price change, Vol/OI, and OI growth.

        Momentum Score = Price_Mom × 0.50 + Vol/OI × 0.30 + OI_Growth × 0.20
        """
        # Price Momentum (50% of momentum)
        df["price_momentum"] = self._calculate_price_momentum(df, options_history)
        df["price_momentum_score"] = self._normalize_momentum(df["price_momentum"])

        # Volume/OI Ratio (30% of momentum)
        df["vol_oi_ratio"] = self._calculate_vol_oi_ratio(df)
        df["vol_oi_score"] = self._score_vol_oi(df["vol_oi_ratio"])

        # OI Growth (20% of momentum)
        df["oi_growth"] = self._calculate_oi_growth(df, options_history)
        df["oi_growth_score"] = self._normalize_oi_growth(df["oi_growth"])

        # Combined Momentum Score
        df["momentum_score"] = (
            df["price_momentum_score"] * self.PRICE_MOMENTUM_WEIGHT +
            df["vol_oi_score"] * self.VOLUME_OI_WEIGHT +
            df["oi_growth_score"] * self.OI_GROWTH_WEIGHT
        )

        return df

    def _calculate_price_momentum(
        self,
        df: pd.DataFrame,
        history: Optional[pd.DataFrame] = None,
    ) -> pd.Series:
        """Calculate 5-day price momentum.

        Returns percentage change from 5 days ago.
        """
        if history is None or history.empty:
            # Without history, use volume as momentum proxy
            if "volume" in df.columns:
                vol_normalized = df["volume"] / (df["volume"].max() + 1)
                return vol_normalized * 20 - 10  # Range -10% to +10%
            return pd.Series(0.0, index=df.index)

        # Match current options to history by contract_symbol or strike+side+expiration
        momentum = pd.Series(0.0, index=df.index)

        for idx, row in df.iterrows():
            contract_id = row.get("contract_symbol", f"{row['strike']}_{row['side']}")

            # Find matching historical data
            if "contract_symbol" in history.columns:
                hist_match = history[history["contract_symbol"] == contract_id]
            else:
                hist_match = history[
                    (history["strike"] == row["strike"]) &
                    (history["side"] == row["side"])
                ]

            if len(hist_match) >= 2:
                # Calculate price change
                old_price = hist_match.iloc[0].get("last", hist_match.iloc[0].get("mark", 0))
                new_price = row.get("last", row.get("mark", 0))

                if old_price > 0:
                    momentum[idx] = ((new_price - old_price) / old_price) * 100

        return momentum

    def _normalize_momentum(self, momentum: pd.Series) -> pd.Series:
        """Normalize price momentum to 0-100 score.

        Formula: min(max(Momentum × 2 + 50, 0), 100)
        - 100% change → Score ~95-100
        - 25% change → Score ~70-75
        - 0% change → Score 50
        - -25% change → Score ~25-30
        """
        return (momentum * 2 + 50).clip(0, 100)

    def _calculate_vol_oi_ratio(self, df: pd.DataFrame) -> pd.Series:
        """Calculate Volume / Open Interest ratio."""
        volume = df.get("volume", pd.Series(0, index=df.index))
        oi = df.get("open_interest", pd.Series(1, index=df.index))

        # Avoid division by zero
        ratio = np.where(oi > 0, volume / oi, 0)

        return pd.Series(ratio, index=df.index)

    def _score_vol_oi(self, ratio: pd.Series) -> pd.Series:
        """Score Volume/OI ratio.

        Formula: min(ratio / 0.20 × 100, 100)
        - Ratio > 0.20: Score 100 (very active)
        - Ratio 0.10: Score 50 (normal)
        - Ratio 0.05: Score 25 (low)
        """
        return (ratio / self.VOLUME_OI_STRONG * 100).clip(0, 100)

    def _calculate_oi_growth(
        self,
        df: pd.DataFrame,
        history: Optional[pd.DataFrame] = None,
    ) -> pd.Series:
        """Calculate Open Interest growth over 5 days."""
        if history is None or history.empty:
            return pd.Series(0.0, index=df.index)

        growth = pd.Series(0.0, index=df.index)

        for idx, row in df.iterrows():
            contract_id = row.get("contract_symbol", f"{row['strike']}_{row['side']}")

            if "contract_symbol" in history.columns:
                hist_match = history[history["contract_symbol"] == contract_id]
            else:
                hist_match = history[
                    (history["strike"] == row["strike"]) &
                    (history["side"] == row["side"])
                ]

            if len(hist_match) >= 1:
                old_oi = hist_match.iloc[0].get("open_interest", 0)
                new_oi = row.get("open_interest", 0)

                if old_oi > 0:
                    growth[idx] = ((new_oi - old_oi) / old_oi) * 100

        return growth

    def _normalize_oi_growth(self, growth: pd.Series) -> pd.Series:
        """Normalize OI growth to 0-100 score.

        Formula: min(max(growth + 50, 0), 100)
        - 50% growth → Score 100
        - 0% growth → Score 50
        - -50% growth → Score 0
        """
        return (growth + 50).clip(0, 100)

    # =========================================================================
    # GREEKS SCORING (25% of total)
    # =========================================================================

    def _calculate_greeks_scores(
        self,
        df: pd.DataFrame,
        underlying_trend: str = "neutral",
    ) -> pd.DataFrame:
        """Calculate Greeks-based score for directional alignment.

        Greeks Score = Delta × 0.50 + Gamma × 0.35 + Vega × 0.10 - Theta_Penalty
        """
        # Delta Score (50%)
        df["delta_score"] = self._score_delta(df, underlying_trend)

        # Gamma Score (35%)
        df["gamma_score"] = self._score_gamma(df)

        # Vega Score (10%)
        df["vega_score"] = self._score_vega(df)

        # Theta Penalty
        df["theta_penalty"] = self._calculate_theta_penalty(df)

        # Combined Greeks Score
        df["greeks_score"] = (
            df["delta_score"] * self.DELTA_WEIGHT +
            df["gamma_score"] * self.GAMMA_WEIGHT +
            df["vega_score"] * self.VEGA_WEIGHT -
            df["theta_penalty"]
        ).clip(0, 100)

        return df

    def _score_delta(self, df: pd.DataFrame, trend: str) -> pd.Series:
        """Score delta based on optimal range and trend alignment.

        For CALLS (bullish): Target delta 0.40-0.70, peak at 0.55
        For PUTS (bearish): Target delta -0.70 to -0.40, peak at -0.55

        Scores peak at 100 when delta is optimal and aligned with trend.
        """
        scores = pd.Series(50.0, index=df.index)

        for idx, row in df.iterrows():
            delta = row.get("delta", 0.5)
            side = row.get("side", "call")
            abs_delta = abs(delta)

            # Base delta score (optimal range scoring)
            if self.OPTIMAL_DELTA_MIN <= abs_delta <= self.OPTIMAL_DELTA_MAX:
                # Peak score at target, decreasing toward edges
                deviation = abs(abs_delta - self.OPTIMAL_DELTA_TARGET)
                base_score = 100 - (deviation / 0.15) * 30  # Max 30 point reduction
            elif abs_delta < self.OPTIMAL_DELTA_MIN:
                # Below optimal range
                base_score = (abs_delta / self.OPTIMAL_DELTA_MIN) * 50
            else:
                # Above optimal range (too deep ITM)
                excess = abs_delta - self.OPTIMAL_DELTA_MAX
                base_score = 70 - (excess / 0.30) * 30

            # Trend alignment multiplier
            if trend == "bullish" and side == "call":
                alignment_mult = 1.0
            elif trend == "bearish" and side == "put":
                alignment_mult = 1.0
            elif trend == "neutral":
                alignment_mult = 0.85
            else:
                # Counter-trend
                alignment_mult = 0.50

            scores[idx] = max(0, min(100, base_score * alignment_mult))

        return scores

    def _score_gamma(self, df: pd.DataFrame) -> pd.Series:
        """Score gamma based on acceleration potential.

        Formula: min(gamma / 0.04 × 100, 100)
        - Gamma > 0.04: Score 100 (excellent)
        - Gamma 0.02: Score 50 (good)
        - Gamma < 0.01: Score 25 (weak)
        """
        gamma = df.get("gamma", pd.Series(0.02, index=df.index))

        return (gamma / self.GAMMA_EXCELLENT_THRESHOLD * 100).clip(0, 100)

    def _score_vega(self, df: pd.DataFrame) -> pd.Series:
        """Score vega for volatility exposure.

        For buying low IV: higher vega = better (benefits from IV expansion)
        Formula: min(vega / 0.30 × 100, 100)
        """
        vega = df.get("vega", pd.Series(0.15, index=df.index))

        return (vega / 0.30 * 100).clip(0, 100)

    def _calculate_theta_penalty(self, df: pd.DataFrame) -> pd.Series:
        """Calculate theta decay penalty.

        Theta_Factor = |Theta| / Mid_Price × 100 (daily decay as % of price)
        Penalty = min(Theta_Factor × 10, 50)

        Capped at 50 to not eliminate high-momentum options.
        """
        theta = df.get("theta", pd.Series(-0.10, index=df.index)).abs()
        mid_price = df.get("mid", df.get("mark", pd.Series(1.0, index=df.index)))

        # Avoid division by zero
        theta_factor = np.where(mid_price > 0, (theta / mid_price) * 100, 10)

        penalty = (pd.Series(theta_factor, index=df.index) * 10).clip(0, 50)

        return penalty

    # =========================================================================
    # SIGNAL GENERATION
    # =========================================================================

    def _generate_signals(self, df: pd.DataFrame) -> pd.DataFrame:
        """Generate trading signals based on framework criteria."""

        # Discount Signal: Low IV + momentum + liquid
        df["signal_discount"] = (
            (df["iv_rank"] < self.DISCOUNT_IV_RANK_THRESHOLD) &
            (df["momentum_score"] > self.DISCOUNT_MOMENTUM_THRESHOLD) &
            (df["spread_pct"] < self.DISCOUNT_SPREAD_THRESHOLD)
        )

        # Runner Signal: High momentum + volume + activity
        df["signal_runner"] = (
            (df["momentum_score"] > self.RUNNER_MOMENTUM_THRESHOLD) &
            (df.get("volume", 0) > self.RUNNER_VOLUME_THRESHOLD) &
            (df["vol_oi_ratio"] > self.RUNNER_VOL_OI_THRESHOLD) &
            (df["spread_pct"] < self.RUNNER_SPREAD_THRESHOLD)
        )

        # Greeks-Aligned Signal: Optimal delta/gamma + liquid
        df["signal_greeks"] = (
            (df["delta"].abs() >= self.OPTIMAL_DELTA_MIN) &
            (df["delta"].abs() <= self.OPTIMAL_DELTA_MAX) &
            (df.get("gamma", 0) > self.GAMMA_GOOD_THRESHOLD) &
            (df["spread_pct"] < self.GREEKS_SPREAD_THRESHOLD)
        )

        # Buy Signal: Composite threshold + at least one signal
        df["signal_buy"] = (
            (df["composite_rank"] > self.BUY_COMPOSITE_THRESHOLD) &
            (df["signal_discount"] | df["signal_runner"] | df["signal_greeks"])
        )

        # Create signal summary
        df["signals"] = df.apply(
            lambda row: self._summarize_signals(row),
            axis=1
        )

        return df

    def _summarize_signals(self, row: pd.Series) -> str:
        """Create comma-separated signal summary."""
        signals = []
        if row.get("signal_discount", False):
            signals.append("DISCOUNT")
        if row.get("signal_runner", False):
            signals.append("RUNNER")
        if row.get("signal_greeks", False):
            signals.append("GREEKS")
        if row.get("signal_buy", False):
            signals.append("BUY")
        return ",".join(signals) if signals else ""

    # =========================================================================
    # UTILITY METHODS
    # =========================================================================

    def _log_ranking_stats(self, df: pd.DataFrame) -> None:
        """Log ranking statistics."""
        logger.info(f"Ranked {len(df)} options contracts")
        logger.info(
            f"Composite range: {df['composite_rank'].min():.1f} - {df['composite_rank'].max():.1f}"
        )

        # Signal counts
        discount_count = df["signal_discount"].sum()
        runner_count = df["signal_runner"].sum()
        greeks_count = df["signal_greeks"].sum()
        buy_count = df["signal_buy"].sum()

        logger.info(
            f"Signals: DISCOUNT={discount_count}, RUNNER={runner_count}, "
            f"GREEKS={greeks_count}, BUY={buy_count}"
        )

        # Top 3 opportunities
        if len(df) >= 3:
            top3 = df.head(3)
            logger.info("Top 3 opportunities:")
            for _, row in top3.iterrows():
                logger.info(
                    f"  {row.get('contract_symbol', 'N/A')}: "
                    f"Rank={row['composite_rank']:.1f}, "
                    f"Signals=[{row['signals']}]"
                )

    def get_interpretation(self, composite_rank: float) -> str:
        """Get human-readable interpretation of composite rank."""
        if composite_rank >= 80:
            return "Exceptional opportunity (all dimensions strong)"
        elif composite_rank >= 65:
            return "Good opportunity (two+ dimensions strong)"
        elif composite_rank >= 50:
            return "Fair opportunity (mixed signals)"
        else:
            return "Poor opportunity (one+ dimension weak)"

    def create_aggressive_config(self) -> "OptionsMomentumRanker":
        """Create ranker configured for aggressive momentum trading."""
        return OptionsMomentumRanker(
            momentum_weight=0.60,
            value_weight=0.25,
            greeks_weight=0.15,
        )

    def create_conservative_config(self) -> "OptionsMomentumRanker":
        """Create ranker configured for conservative value hunting."""
        return OptionsMomentumRanker(
            momentum_weight=0.20,
            value_weight=0.60,
            greeks_weight=0.20,
        )

    def create_greeks_focused_config(self) -> "OptionsMomentumRanker":
        """Create ranker configured for Greeks-focused risk management."""
        return OptionsMomentumRanker(
            momentum_weight=0.25,
            value_weight=0.30,
            greeks_weight=0.45,
        )


class IVHistoryCalculator:
    """Calculate IV statistics from historical data."""

    @staticmethod
    def calculate_iv_stats(
        iv_history: pd.DataFrame,
        current_iv: float,
        lookback_days: int = 252,
    ) -> IVStatistics:
        """Calculate 52-week IV statistics.

        Args:
            iv_history: DataFrame with 'date' and 'iv' columns
            current_iv: Current implied volatility
            lookback_days: Days to look back (default 252 = 1 year)

        Returns:
            IVStatistics with high, low, median, current, and rank
        """
        if iv_history is None or iv_history.empty:
            # Return default stats if no history
            return IVStatistics(
                iv_high=current_iv * 1.5,
                iv_low=current_iv * 0.5,
                iv_median=current_iv,
                iv_current=current_iv,
                days_of_data=0,
            )

        # Sort by date and take last N days
        df = iv_history.copy()
        if "date" in df.columns:
            df = df.sort_values("date", ascending=False)
        df = df.head(lookback_days)

        iv_col = "iv" if "iv" in df.columns else "implied_volatility"

        return IVStatistics(
            iv_high=df[iv_col].max(),
            iv_low=df[iv_col].min(),
            iv_median=df[iv_col].median(),
            iv_current=current_iv,
            days_of_data=len(df),
        )

    @staticmethod
    def calculate_iv_percentile(
        iv_history: pd.DataFrame,
        current_iv: float,
    ) -> float:
        """Calculate IV Percentile: % of days IV was below current.

        IVP = (Number of days with IV < current) / Total days × 100
        """
        if iv_history is None or iv_history.empty:
            return 50.0

        iv_col = "iv" if "iv" in iv_history.columns else "implied_volatility"
        below_count = (iv_history[iv_col] < current_iv).sum()
        total = len(iv_history)

        if total == 0:
            return 50.0

        return (below_count / total) * 100
